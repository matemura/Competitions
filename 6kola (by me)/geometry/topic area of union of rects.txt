Дадени са N правоъгълника с положителни целочислени координати, да се каже колко е лицето на площта, която се покрива от тях.

keywords: plane compression, union of intervals, sweep line, binary indexed tree, segment (interval) tree

Решения:

[b][center]Решения с разделяне на малки квадратчета/правоъгълничета[/center][/b]

1) разделяме равнината на квадратчета, като квадратче с координати на противоположните ъгли (x,y,x+1,y+1) ще считаме че има координати просто (x,y) в някакъв двумерен масив [b]a[/b]. За всеки правоъгълник (x1,y1,x2,y2) маркираме квадратчетата, които покрива:
[code]
for (int x=x1; x<x2; x++)
 for (int y=y1; y<y2; y++)
  a[x][y]=1;
[/code]

и просто събираме лицето на покритите квадратчета:
[code]
ans=0;
for (int x=0; x<MAXC; x++)
 for (int y=0; y<MAXC; y++)
  ans+=a[x][y];
[/code]

като MAXC е най-голямата стойност на x или y на правоъгълник. Минимални подобрения са възможни, но като цяло сложността на това е O(N*MAXC*MAXC)


2) правим "компресиране" на равнината. Във вариант 1 се маркират прекалено много излишни квадратчета. Може вместо да гледаме по отделно всички квадратчета с x и y координати измежду всичките 0,1,2,3...MAXC, да ги групираме в правоъгълници, като тези правоъгълници ще са с координати на краищата само измежду въведените. Демек вземаме всички x-координати във входа, сортираме ги, и първата от тях я кръщаваме 0, втората - 1, третата - 2 и т.н. После променяме координатите на всичи въведени правоъгълници да са с новите им съответни. Например правоъгълниците (100,345,234,501) и (52,400,301,501) ще образуват X[]={52,100,234,301} и Y[]={345,400,501}. Новите правоъгълници ще са (1,0,2,2) и (0,2,3,2) и сега чисто и просто решаваме задачата по първия начин, само че за новите правоъгълници, с разликата, че за всяко маркирано "квадратче" (а то всъщност е група квадратчета, демек правоъгълниче) не прибавяме 1, а (X[x+1]-X[x])*(Y[y+1]-Y[y]) = лицето на съответстващото правоъгълниче. Сложността е O(N^3). Примерна реализация:

[code]
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <fstream>
#include <queue>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
#include <ctime>


#define SZ size()
#define PB push_back
#define ALL(v) v.begin(),v.end()
#define MP make_pair
#define x first
#define y second

#define LL long long
#define UI unsigned int
#define ULL unsigned long long
#define PI pair<int,int>
#define PD pair<double,double>
#define PLL pair<LL,LL>
#define PULL pair<ULL,ULL>
#define VI vector<int>
#define VD vector<double>
#define VS vector<string>
#define SI set<int>
#define PQ priority_queue
#define VVI vector<vector<int> >
#define IT iterator

#define ABS(x) (((x)>0)?(x):(-(x)))
#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))
#define sign(a) ((a)>0)-((a)<0)
#define sqr(a) ((a)*(a))
#define Repi(n) for (int i=0; i<n; i++)
#define Repj(n) for (int j=0; j<n; j++)
#define Repk(n) for (int k=0; k<n; k++)
#define F(i,n) for (int i=0;i<n;i++)

#define INF 2000000000
#define EPS 1e-6

#define Time ((double)clock()/CLOCKS_PER_SEC)
#define pause system("pause")

using namespace std;

#define MAXN 128

int N;
struct rect{ int x1,y1,x2,y2; rect(){}; rect(int a,int b,int c,int d){ x1=min(a,c),y1=min(b,d),x2=max(a,c),y2=max(b,d); }; };
rect r[MAXN];
map<int,int> X,Y;
int xs[MAXN*2],ys[MAXN*2],xn,yn;

int col[MAXN*2][MAXN*2];

void print()
{
    printf("   "); Repi(yn) printf("%3d",ys[i]); cout<<endl;
    Repi(xn)
        { printf("%3d",xs[i]); Repj(yn) printf("%3d",col[i][j]); cout<<endl; }
}

int main()
{
    scanf("%d",&N);
    Repi(N)
     {
            int a,b,c,d; scanf("%d%d%d%d",&a,&b,&c,&d);
            r[i]=rect(a,b,c,d); r[i].x2,r[i].y2;
            X[r[i].x1]=X[r[i].x2]=Y[r[i].y1]=Y[r[i].y2]=666;
     }
    for (map<int,int>::iterator it=X.begin(); it!=X.end(); it++)
        xs[xn++]=it->x,it->y=xn-1;
    for (map<int,int>::iterator it=Y.begin(); it!=Y.end(); it++)
        ys[yn++]=it->x,it->y=yn-1;

    
    Repi(N)
     {
            int x1=X[r[i].x1],x2=X[r[i].x2],y1=Y[r[i].y1],y2=Y[r[i].y2];
            for (int x=x1;x<x2;x++)
             for (int y=y1;y<y2;y++)
              col[x][y]=1;
     }

    int ans=0;
    Repi(xn-1)
     Repj(yn-1)
      ans+=col[i][j]*(xs[i+1]-xs[i])*(ys[j+1]-ys[j]);
    printf("%d\n",ans);

    return 0;
}[/code]


3) Компресираме само по едната координата, примерно по x. За всяко x (отговарящо за вертикалната "лентичка" от X[x] до X[x+1]) правим списък със всички y-координати, на които започва или свършва част от даден правоъгълник между X[x] и X[x+1]. После сортираме тези y-координати за всяко x и на практика решаваме задачата "дадени са интервали, колко е дължината на покритата част от линията" за всяко x. Абе за правоъгълник (x1,y1,x2,y2) обхождаме x=x1..x2 и правим a[x].push_back(make_pair(y1,1)) и a[x].push_back(make_pair(y2,-1)) , като x1 и x2 са компресиране координати, а y1 и y2 не са. Пример: правоъгълници (2,17,9,30), (6,21,11,35) и (11,17,12,21) с X[]={2,6,9,11,12}. Правим списци vector<pair<int,int> > a[0]={ (17,1) , (30,-1) }, което означава, че между x координати 2 и 6, на y-координата 17 започва правоъгълник, който свършва на y-координата 30. После a[1]={ (17,1) , (21,1) , (30,-1), (35,-1) }. Нататък е аналогично. После правим линейно обхождане на всяко a[x] и намираме дължината на покрития участък, като я умножаваме с (X[x+1]-X[x]), за да получим лицето. Аналогично се решава colxor от ЗМС'07 (която обаче не може да се реши ефективно по някой от другите методи с броене и маркиране на квадратчета). Сложността на това е O(N*N*logN) заради сортирането на елементите от всяко a[x].

4) Смесица между 2 и 3 - компресираме и двете координати, но вместо за всяко x да обхождаме всяко y и да маркираме квадратчета, ние за всяко x маркираме само началното и крайното квадратче (y1 и y2), по малко по-особен начин. Всъщност, цикъла за маркиране изглежда така (вж. примерната реализация на 2):
[code]
for (int x=x1;x<x2;x++)
 col[x][y1]++,col[x][y2+1]--;
[/code]
Де факто това казва: за дадено x, на позиция y = y1 започва парче от правоъгълник, което свършва на позиция y = y2+1 (понеже последното му квадратче е във y = y2 и чак на следващото, y2+1, вече това парче изчезва). Да погледнем примера от 3 - ще се получи col[0]={1,0,-1,0} <=> между X[0]=2 и X[1]=6, квадратчето между позиции Y[0]=17 и Y[1]=21 е първото от някакъв правоъгълник (добавя правоъгълник), а квадратчето между Y[2]=30 и Y[3]=35 е първото, което не е от някакъв правоъгълнк (изважда правоъгълник). Аналогично имаме col[1]={1,1,-1,-1} (за между X[1]=6 и X[2]=9); col[2]={0,1,0,-1} (между X[2]=9 и X[3]=11); col[3]={1,-1,0,0} (за м/у X[3]=11 и X[4]=12). Сега, как разбираме за дадено квадратче дали да го добавим или не? Отново разглеждаме всяко х по отделно, но този път поддържаме в един брояч в колко правоъгълника сме "влезли" от началото на реда, демек колко правоъгълника покриват текущата клетка (този брояч се нулира за всяко х). Сиреч
[code]
for (int x=0;x<xn;x++)
 {
	int t=0;
	for (y=0;y<yn;y++)
	 {
		t+=col[x][y];
		if (t) ans+=(xs[i+1]-xs[i])*(ys[j+1]-ys[j]);
	 }
 }
[/code]
Всъщност за всяко квадратче [x,y] можем да намерим от колко правоъгълника се покрива само като сумираме всички col[x][0]+col[x][1]+...+col[x][y]. Именно това прави този цикъл - обхожда квадратчетата ред по ред, намира тази сума за всяко и пита дали е положителна - ако е, значи квадратчето е покрито от поне един правоъгълник и трябва да се добави към сумата. Сложността е O(N^2).



[b][center]Решения със sweep line[/center][/b]


...SOON...




[i]tasks:
evrika/2008-2009/p3
baltic/2001/mar
noi/2006/k1/skymap (3D аналог - по-късно ще го обсъждаме и него ;))
[/i]