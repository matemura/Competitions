всички знаем как се намира най-малкото общо кратно на две числа ( = greatest common divisor = GCD)

[center]int gcd(int a,int b)
{ return (b)?gcd(b,a%b):a; }[/center]

-- припомняне, че 
         [code]x = (булев_израз)?(израз1):(израз2) [/code]
   е същото като [code] if (булев_израз) x=израз1; else x=израз2; [/code]
само че по-бързо и по-готино. 

-- също и че булевата стойност на променлива е нула ако променливата е с числова стойност 0, иначе е 1. Демек 
[code]   int x; cin>>x;
   if (x) cout<<" x e razli4no ot 0\n";
   if (!x) cout<<"  x e ravno na 0\n";[/code]

.....

това е рекурсивна реализация на древния евклидов алгоритъм (обяснен е просто и ясно тук [url]http://bg.wikipedia.org/wiki/Алгоритъм_на_Евклид[/url] )

ако ви мързи и тази плюнка да напишете, може да ползвате на готово __gcd(int,int) от iostream, но е много важно да знаете на какъв принцип работи!!! на базата на него може да си изведете Разширения алгоритъм на Евклид, който намира за 2 цели числа a и b други 2 цели x и y, такива че
[center]a*x + b*y = gcd(a,b)[/center]

to be continued...
















[code]pair<int, int> ext_gcd(int a, int b)
{
 if(!b) return make_pair(1, 0);
 pair<int, int> res = ext_gcd(b, a%b);
 return make_pair(res.second, res.first - a/b);
}
[/code]

Така... 
Да приемем за по-кратко писане, че gcd(a, b) = d.

И сега искаме да намерим такива x и y, че ax + by = d.
Ако b=0, решението е тривиална - d = a => а.1 + b.0 = d - това ни е и дъното на рекурсията, аналогично на обикновения алгоритъм.
Сега разглеждаме b!=0.
Значи можем да делим на b - кръщаваме си a/b = p, a%b = q, което си е същото като a = p*b + q.
Аналогично на обикновения алгоритъм намиране отговора за b, a%b - т.е. за b, q. Т.е. знаем, че b*res.first + q*res.second = d...
Сега искаме да получим някъв израз с a и b, който да можем да изравним с тоя. Да приемем, че ще ги умножаваме по същите неща, щото звучи логично, и да разгледаме b*res.first + a*res.second
b*res.first + a*res.second = b*res.first + (p*b + q) * res.second = (b*res.first + q*res.second) + p*b*res.second = d + p*b*res.second.
b*res.first + a*res.second = d + p*b*res.second | вадим p*b*res.second от двете страни
b*(res.first - p*res.second) + a*res.second = d, p = a/b, щото така сме го въвели...
b*(res.first - a/b * res.second) + a*res.second = d

Значи числата, които ни трябват, са res.second(по него умножаваме a), и res.first - a/b * res.second(по него умножаваме b).















ето тука да си го разигравате и да гледате какво става ->
http://2000clicks.com/MathHelp/NumberChineseExtendedEuclideanAlgorithm.htm


ето и по-лесен (и безмозъчен) начин да го помните това нещо:


[code]u = { 1,0,a }
v = { 0,1,b }

while (u3 % v3 !=0 )
  q = u3 / v3
  t = u - v * q
  u=v
  v=t

x = v1
y = v2
gcd(a,b) = v3[/code]

като това, разбира се, е псевдо-код.
забележете, че u, v и t са вектори и под u1,u2 v3 имам предвид първия, втория елемент на u и пр.
също така под t = u - q*v се подразбира t1=u1-q*v1, t2=u2-q*v2, t3=u3-q*v3 (q е число)
забележете колко това наистина прилича на "простия" евклид само за gcd - докато числата могат се делят едно на друго, вземаме остатъка на едното при деление с другото (векторът t се явява точно това - от u вадим v по остатъка при деление на u3 с v3 ), разменяме ги и продължаваме. накрая резултатът е във вектора v