Задача: [b]колко е x на степен n[/b]. Тъй като това много често е бая тлъсто число, в повечето случаи ще го искат по даден модул MOD. Когато "ans=1; for (int i=0;i<n;i++) ans=(ans*x)%MOD;" работи прекалено бавно, се налага да правим по-хитри неща. pow() от <cmath> за съжаление не работи с модулна аритметика. Да видим - ако знаем колко е y^k, можем много лесно да кажем колко е y^(2*k) или y^(2*k+1), нали? Еми от това следва следния "разделяй и владей" метод за бързо повдигане на степен със сложност O(logN):
[code]int power(int x,int n)
{
   if (n==0) return 1;
   if (n%2) return power(x,n/2)*power(x,n/2)*x;
   else return power(x,n/2)*power(x,n/2);
}[/code]

Това обаче много пъти ще пресмята една и съща степен, което прави сложността доста по-голяма на практика. Затова е добре да го пишем итеративно (умишлено не съм писал работа по модул, за да е по-прегледно, но иначе си представяйте, че навсякъде е x=(x*y)%MOD).
[code]
typedef unsigned long long tip;

tip power(tip x,tip n)
{
  tip ans=1,tmp=x;
  while (n)
    {
        if (n&1) ans*=tmp;
        tmp*=tmp;
        n>>=1;
     }
   return ans;
}
[/code]

какво прави това: търсим 3^26. Алгоритъмът ще действа така:
- 26 дели ли се на 2? Да => не пипаме отговора. tmp = 3*3 = 9.
- 13 дели ли се на 2? Не => отговора умножаваме с tmp => ans = 9. tmp = 9*9 = 81.
- 6 дели ли се на 2? Да => нищо. tmp = 81*81 = 6561
- 3 дели ли се на 2? Не => ans = 9 * 6561 = 59049. tmp = 6561^2 = 43046721
- 1 дели ли се на 2? Не => ans = 59049 * 43046721 = ....., tmp = 43046721^2 = ....

Защо работи? Еми разпишете си няколко примера с рекурсивния вариант, разпишете си ги и с итеративния и ще видите :P
Иначе може да използвате нестандартната power от namespace __gnu_cxx, но трябва да си предефинирате оператор *, разбира се. Може да хвърлите един поглед на това http://mathforum.org/library/drmath/view/55603.html .