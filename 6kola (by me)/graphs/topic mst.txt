a.k.a. Minimum spanning tree - минималко покриващо дърво
от всички покриващи дървета искаме това, на което сумата от теглата на ребрата е най-малка

[center][b]Kruskal's algorithm[/b][/center]

1. разделяме графа на свързани компоненти (множества); в началото всеки връх е собствена компонента
2. почваме последователно да строим дървото, като вземаме последователно ребрата в [u]нарастващ[/u] ред според теглата им
 2а. ако добавянето на текущото ребро ще свърже две различни компоненти (демек ако реброто не е между върхове, които вече са в едно множество) - тогава го вземаме и обединяваме компонентите на двата му върха
 2б. иначе не го вземаме
3. всички взети ребра образуват MST-то на графа

note: за обединяването на множества се използва ултра-яката структура disjoint sets -> http://6kola.eblahfree.com/Blah.pl?m-1233606346/s-0/


реализация (върховете започват от едно при четенето; иска се сумата от теглата на ребрата в дървото):

    структурата за множествата ( [url=http://6kola.eblahfree.com/Blah.pl?m-1233606346/s-0/]зема се от тук[/url] )
[code]#define MAXN 100005
#define MAXM 1000005

int par[MAXN],rank[MAXN];  // това par се отнася за родителя в дърветата на множествата, които нямат НИЩО ОБЩО с минималното покриващо дърво, освен че са все дървета

int initialize()
{
	for (int i=0;i<N;i++) par[i]=i,rank[i]=0;
}

int root(int x)
{
	if (par[x]==x) return x;
	return par[x]=root(par[x]);
}

int unite(int x,int y)
{
	x=root(x);
	y=root(y);
	if (rank[x]>rank[y]) par[y]=x;
	else if (rank[y]>rank[x]) par[x]=y;
	else par[y]=x,rank[x]++;
}[/code]

    типът на ребрата (формалности... може и по-просто ама си припомнете тоя начин)
[code]int N,M;

struct edge
  { 
	int a,b,c;
	edge(){};
	edge(int aa,int bb,int cc)
	 { a=aa,b=bb,c=cc; };
  };
bool operator<(const edge &X,const edge &Y)
  { return X.c<Y.c; }

int edges[MAXM];[/code]

     иии батко
[code]int Kruskal()
{
	sort(edges,edges+M);
	int res=0;
	for (int i=0;i<M;i++)
	 {
			int a=edges[i].a,b=edges[i].b;
			if (root(a)==root(b)) continue;
			res+=edges[i].c;
			unite(a,b);
	 }
	return res;
}[/code]

   и мейн-а[code]int main(
{
	scanf("%d%d",&N,&M);
	int a,b,c;
	for (int i=0;i<M;i++)
	 scanf("%d%d%d",&a,&b,&c),edges[i]=edge(a-1,b-1,c);
	 
	printf("%d\n",Kruskal());
	return 0;
}[/code]

алтернативни реализации има в постовете

сложността на алгоритъма е O(MlogM) за сортирането + за всяко от M-те ребра по две-три викания на операциите, които са бая по-бързички от logM, така че сложността си e колкото едно сортиране


[center][b]Prim's algorithm[/b][/center]

чичо Прим предлага съвсем различен метод - вземаме един връх да е корен на mst-то и почваме да го строим като добавяме върхове към текущото дърво
само че добавяме нов връх само ако реброто, което го свързва с дървото, е по-евтино от всички други такива ребра (свързващи недобавени върхове с дървото)

...я сега да погледнем [url=http://6kola.eblahfree.com/Blah.pl?m-1230106299/s-0/][u][b][i]дийкстрата[/i][/b][/u][/url] и да видим, че се различава единствено по това, че там добавяме ако целия път от корена до новия връх е минимален, а при Прим - ако само цената на новото ребро е минимална. Самите реализации са абсолютно аналогични. Единствената разлика в сорса е, че не сравняваме с [code]t.d + cost[t.v][i][/code], а само с [code]cost[t.v][i][/code]. Пример (с приоритетна опашса, O(MlogN), 1:1 взето от другата тема):

[code]void prim(int src)
{   
     PQ<PI,vector<PI> ,greater<PI> > q;
     q.push(MP(0,src));
     while(!q.empty())
       {
            PI t=q.top();  
            q.pop();
            if(used[t.v]) continue;
            used[t.v]=1;
            for(i=0;i<=adj[t.v].size();i++)
               {
                      int next=adj[t.v][i];
                      if(d[next] > cost[t.v][i])
                         {
                              d[next]=cost[t.v][i];  //променяме
                              p[next]=t.v;
                              q.push(MP(d[next],next)); //и пъхаме (не махаме)
                         }
               }
       }
}[/code]

разбира се, всяка една друга реализация на Дийкстра е алтернатива и за Прим (N^2 доста често се оказва по-удачната реализация за Прим, тъй като в много задачи искат на пълен граф да се намери MST-то)



а кой от двата MST алгоритъма ще пишете? Ами сложностите теоритично са равни, Крускал понякога е по-бърз, но мене лично Прим ме кефи повече щот е Дийкстра ;)

[i]tasks:
usaco/2008/nov/gold/cheer
srm 432/div1/builderscountry[/i]