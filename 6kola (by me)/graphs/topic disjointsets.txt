[center][b]Disjoint sets (някъде му викат union find)[/b][/center]
http://en.wikipedia.org/wiki/Disjoint-set_data_structure

имаме елементи, като всеки елемент принадлежи на точно едно множество
искаме да извършваме операции "[u]елементи А и Б от едно множество ли са?[/u]" и "[u]обедини множествата на елементи А и Б![/u]" с прилична сложност

иии:
0. правим гора, като всяко дърво е дадено множество ; за всеки връх пазим родителя му в дървото на неговото множество ; родителят на корен е самият корен
1. при питане дали два върха са в едно множество, намираме корените на дърветата им и ги сравняваме
2. при обединяване - намираме корените на двата въпросни върха и правим родителя на единия корен да е равен на другия

ето проста реализация:
[code]#define MAXN 1024
int par[MAXN],N;

int initialize()   // това прави всеки елемент да е сам в началото
{
	for (int i=0;i<N;i++) par[i]=i;
}

int root(int x)    // намира корена на дървото на х
{
	if (par[x]==x) return x;
	return root(par[x]);
}

int unite(int x,int y)  //ясно...
{
	x=root(x);
	y=root(y);
	par[y]=x;
}[/code]

това нещо върши работа. НО! Ако се наложи, примерно, след инициализацията да обединим 0 с 1, после 1 с 2, после 2 с 3 и т.н., дървото на 0 ще се изроди в списък и сложността на една операция ще стане линейна (всеки път root() ще тръгва от последния елемент нагоре по родителите, докато не стигне до нулата, при което де факто ще обходи всички елементи преди текущия). Има нужда от подобрения...

не може ли като намерим корена на даден връх, ние директно да го "откачим" от там където виси вмомента и да го закачим за корена му? по този начин ще съкратим пътя, който ще се обхожда от root

[code]int root(int x)
{
	if (par[x]==x) return x;
	return par[x]=root(par[x]);
}
[/code]
с немного усилия това може да се препише итеративно, което също леко ще забързи (ама не много)

другата евристика (!=оптимизация) е да се стремим да добавяме по-малките дървета към по-големите (на принципа на мегамултикорпорациите ;) ). За тази цел на всеки корен съпоставяме ранг и добавяме тези с по-малки рангове към тези с по-големи, като при равенство избираме единия да е големия и му увеличаваме ранга

[code]
...
int rank[MAXN];

int initialize()
{
	for (int i=0;i<N;i++) par[i]=i,rank[i]=0;
}
...

int unite(int x,int y)
{
	x=root(x);
	y=root(y);
	if (rank[x]>rank[y]) par[y]=x;
	else if (rank[y]>rank[x]) par[x]=y;
	else par[y]=x,rank[x]++;
}[/code]

тези две простички подобрения правят сложността на една операция почти константна.


[i]tasks:
   [b]Kruskal's MST[/b] algorithm http://6kola.eblahfree.com/Blah.pl?m-1231667827/s-0/#num1
   usaco/2009/jan/gold/travel
   noi/2008/k1/bicon (alternative sol)[/i]
