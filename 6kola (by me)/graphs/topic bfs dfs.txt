обхождания на непретеглен граф без повтаряне на върхове, с построяване на покриващо дърво:

[b][center]DFS[/center][/b]

използва се за намиране на път, топологично сортиране, свързаност и артикулационни неща

[i] [b]tasks: [/b](paths) maze; usopen 2006, silver - wall ; usaco oct 06, silver - skate ; ioi 07, flood*
           (topsort) usaco mar 07, gold - ranking; 
	 (connectedness) all connected component; strongly conn. comp.;all cycles in undirected graph(directed ne sta - cross edges ebavat); noi 03, friend; croatian noi 06-07 - policija* ; srm 328 blockenemy ; k1 2008 bicon* ; srm 312 antarcticapolice* ; tchs07 round 3 gamma, provinces ; 
	 (tree shits) subtree size; k1 2007, split; zimni 07 - store (mod arithm!)
	 (bf) srm 396 - fiximage;
	 usaco training - mnogo![/i]


VI adj[v] - съседите на v
int used[v] - дали връх v е използван
VI children[v] - децата на v в дървото
int parent[v] - родителят на v (сиреч с горното показват tree edges)
int level[v] - нивото на v в дървото (коренът е на ниво 0)
int low[v] - най-ниското ниво, до което стига някой от наследниците на v директно с ребро (заедно с level намират артикулационни точки, мостове, двусвързани компоненти и др.)
VI backedges[v] - обратните ребра от v
VI forwardedges[v] - предните ребра от v
int order[j] - реда, в който dfs-то е [u]влизало[/u] във върховете (използва се при [u]ореантирани[/u] графи за топологично сортиране и за намиране на силносвързани компоненти)
int ordc - брояч за горното нещо
int order2[j] - реда, в който сме [u]минавали[/u] през върховете (използва се при намиране на lowest common ancestor (LCA) с O(1) и за проверка дали даден връх е ((((...)пра)пра)пра)дядо на някой друг връх с O(1) )
int ordc2 - брояч за тва чудо
int prenum[v] - къде v се среща за пръв път в order2
int postnum[v] - ...и къде за последен (също требат за тея лайна на order2[])
int subtree[v] - колко е голямо поддървото на v (по брои върхове)
int next - временна променлива за текущо дете (и [u]не[/u] е равно на i в цикъла !!!)

примерен код за dfs в [u]неореантиран[/u] граф:
[code]
void dfs(int v)
{
	used[v]=1;
	low[v]=level[v]; //2.5
	order[ordc++]=v;  //4
	prenum[v]=ordc2; //5
	order2[ordc2++]=v; //5
	subtree[v]=1; //3
	for (int i=0;i<adj[v].size();i++)
	 {
			int next=adj[v][i];
			if (!used[next])
			 {
					parent[next]=v; //1
					children[v].push_back(next); //1
					level[next]=level[v]+1;  //2
					dfs(next);
					subtree[v]+=subtree[next]; //3
					low[v]=min(low[v],low[next]); //2.5
					order2[ordc2++]=v; //5
			 }
			else
			 if (level[next]+1<level[v]) //1
			  {
			    backedges[v].push_back(v); //1
			    low[v]=min(low[v],level[next]); //2.5
			  }
			 else
			  if (level[v]+1<level[next]) //1
			   forwardedges[v].push_back(next); //1
	 }
	postnum[v]=ordc2-1; //5
}
[/code]

note: където срещу ред има "// число" значи, че тоя ред върви за ръчичка с всички други редове с това число (които правят конкретна гъзарийка) и че може и без него в най-простото dfs
note: някои от тея неща се използват само когато графът е дърво
note:[b] за ореантиран граф искам някой от вас да ми напише код ;)[/b]

има и iterative dfs, където се прави пълна итеративна симулация на dfs с while цикълче и ваш си стек (прави се когато има stack overflow на нормалното dfs)
има и по-просто итеративно dfs, което много прилича на bfs (просто вземаме за текущ елемент последния, а не първия в опашката) само че си има недостатъци
има и dfs с iterative deepening, където dfs-то се пуска да стига само до определено ниво, като на следващата стъпка се пуска да стига до следващото ниво, след това до по-следващото и пр (служи когато търсим най-къс път, а bfs е много трудно за писане)

[b][center]BFS[/center][/b]

използва се за най-къс път, за свързаност (не става да артикулационни неща, щото вместо back/forward edges има само cross edges, и при неореантираните) и в модифициран вариант много ще го пишем при игрите, така че засега няма много да го разфасовам

[i][b]tasks:[/b] (shortest path) proleten 07 - hop; shortest path in maze; ioi 89; 
	(connectedness) poi 2004/2005, hollows*[/i]

int q[i] - опашка
int st,en - начало и край на опашката
v - текущ връх
MAXQ - размер на опашката (при въртяща опашка, когато паметта не стига и можем само да се молим на Господ това да проработи)
другите лайна са почти същите като при dfs, ама ме мързи да ги пиша. Мисля че е ясно къде ще се сложат, само дето тука има и cross edges при неореантираните графи (а пък няма cross и back edges) и някои от екстрите стават безсмислени

[code]
q[0]=root;
used[root]=1;
for (int st=0,en=1; st!=en; st++)
 {
		if (st==MAXQ) st=0; // 1
		int v=q[st];
		for (int i=0;i<adj[v].size();i++)
		 {
				int next=adj[v][i];
				if (used[next]) continue;
				used[next]=1;
				parent[next]=v;
				level[next]=level[v]+1;
				q[en++]=next;
				if (en==MAXQ) en=0; // 1
		 }
 }
[/code]

note: в level[v] пише въпросния най-къс път от root до v

при дърветата има вариант за bfs от листата към корена и именно него ще пишем при игрите