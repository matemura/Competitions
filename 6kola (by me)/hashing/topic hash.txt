[b]1. що е то хеширане? [/b]
 Имаме някакви големи неща (думи,големи числа,масиви,структури, класове,графи,крави,кокошки и пр.) и искаме да боравим с тях чевръстичко. Примерно искаме да разбираме дали две думи са равни със сложност O(1), вместо символ по символ да ги питаме. Или пък имаме много на брой различни дървета и искаме за всяко да знаем колко изоморфни на него има, без да пишем map<vector<pair<set<prioritu_queue> > > ,int> понеже е много бавно.
 Ах, колко по-лесно би било думите да бяха int-ове и да пишем светкавичното if (a==b) вместо линейното if (strcmp(a,b)==0), или пък еднаквите дървета също да бяха int-ове и просто да пишем count[current_tree]++ вместо някакви извращения. Е, за всеобщ смут и възхищение, те МОЖЕ да бъдат прости, малки, компактни и удобни за работа чисълца!!!!! Йеей!!!

[b]2. а?[/b]
 Идеата е, че когато имаме обхватен брой обекти (keys) от иначе необхватно голямо множество възможности, можем на всеки обект да съпоставим някакво случайно число (hash value) от доста по-малък интервал. И то така, че на еднаквите обекти да се съпоставят еднакви числа, а на различните - различни числа. Като това трябва да става бързо, иначе се губи смисълът. В основата на тази магия седи думата [i]рандомизация[/i] - избраните хеш-числа (така им се вика) трябва да са колкото се може по-хаотични.
 Проблемът е, че колкото и да сме готини и на всяка възможна дума да съпоставяме различно число от интервала [1..10000], то като се въведат 10000 различни думи, 10001-вата дума просто няма къде да ходи и ще се наложи да й присвоим някое хеш-число, което вече е "заето" от друга дума. Това се нарича колизия (collision) - когато на различни keys съпоставим еднакви hash values, като по този начин спираме да ги разграничаваме и един вид ги приравняваме. А в повечето случаи е кофти програмата ти да си мисли, че "abracadabra" е равно на "aaaaaaaaaaaaaa". Как да се справяме с колизиите - по-нататък.

[b]3. пример за хеширане (по действителен случай!!!)[/b]
   класика: въвежда се дума от 10 000 000 символа и след нея друга дума от мах 1 000 000 символа. На кои позиции в първата се среща втората дума?

   brute force ще е много бавно. Не сме чували за knuth-morris-pratt. Идея! Може да пазим до всяка позиция на първата дума сумата на символите. И сумата на символите на търсената дума.

   примерно при s="asdfaasack" и s1="as";
    sum[0]=1;
    sum[1]=1+19
    sum[2]=1+19+4
    sum[3]=1+19+4+6
    ...
    sum[9]=1+19+4+6+1+1+19+1+3+11
    sums1=1+19
   
  така почваме и за всяка позиция от s гледаме дали сумата на следващите символа е равна на сумата на s1. 
    for (int i=0; i<n-m+1; i++) if ( sum[i+m-1]-sum[i-1] == sums1 ) printf("found at position %d\n",i);

  и я виж ти - Мом откри хеширането. Само дето очевидно стават много колизии в голяма част от случаите това лайно ще каже, че е намерило s1 в s без изобщо да е вярно (даже в горния пример ще каже 3 срещания, при положение, че са две, защото няма да различи "as" от "sa" - хеш-стойността и на двете думи е 20 и за алгоритъма те на практика са равни). С това хванах около 22 от 100 (ама имах повече от Рости :)))) )

[b]4. хеширане на думи (по умния начин)[/b]
   по принцип няма универсален алгориътм за хеширане, а се определя за всяка задача поотделно. Но думите е прието да се представят като числа в бройна система с основа големината на азбуката, като на всяка буква се съпоставя цифра. Така например на "[u]cafd[/u]" му съответства 2*26^3 + 0*26^2 + 5*26^1 + 3*26^0 = [u]35285[/u] (разира се, ако азбуката е само от малки латински букви). Това може да се сметне като пресметнете предварително степените на основата, които така или иначе най-вероятно ще ви трябват после (не искате да ги смятате наново всеки път, вярвайте)
[code]
int pow26[]={ 1,26, 676, 17576...... };
int hash(char s[],int n)
{
  int ret=0;
  for (int i=0,p=n-1; i<n; i++,p--)
   ret += (s[i]-'a') * pow26[p]; 
  return ret;
}
[/code] 

...или чрез т.нар. rolling hash, който де факто използва принципа на Хорнер за уравнение от n-та степен [ че 5*x^3 + 7*x^2 + 10*x^1 + 8*x^0 = ((5*x+7)*x+10)*x+8 ]
[code]...
for (int i=0;i<n;i++)
 ret = ret*26 + (s[i]-'a');
[/code]
  помните ли как като малки превръщахте низове в числа?
[code]  char s[]="16432\0";
  int num=0;
  for (int i=0; s[i]; i++)
    num = num * 10 + (s[i] - '0');
  printf("4isloto e %d\n",num);
[/code]
 ...е, rolling hash-ът е абсолютно същото, само дето основата не е 10. Когато някой път се оплетете с хешове на думи, сетете се за тази аналогия и мислете как щяхте да действате ако ви бяха дадени числа и всичко ще е ок ;)

  Сега, очевидно броят на различните възможности ча числа по този начин образувани е равен на броя на различните възможни думи, така че на практика досега ние нищо не сме компресирали. За да се нарече това чудо хеширане, трябва да вземаме получените числа по някакъв модул (иначе стават огромни). Този модул трябва да е [u]взаимно прост с основата[/u]!!!! Това е много важно, иначе ще се избочи от колизии много. Заради това е добре да вземете основата да е някое просто число, примерно 29 или 31, за да е сигурно, че са взаимно прости. Модулът го правим според задачата. Сега хеш-функцията (тази дето й даваш обект (key), а тя ти връща hash value) вече изглежда така:

[code]const int MOD = 1234567891;
const int base = 29;
int hash(char s[],int n)
{
  int ret=0;
  for (int i=0; i<n; i++)
   ret = ( ret * base + s[i] - 'a' ) % MOD;
  return ret;
}
[/code]

   Супер. Да видим сега нашата задача от точка 3. Пак до всяка позиция на s ще пазим хеша, ама как ще правим сравняването? Как ще вземем хеша на някакъв междинен подниз на s като използваме само тази информация? С простата сума на символи беше лесно, ама сега си иба мамата.
   Да погледнем как бихме процедирали, ако вместо думи имахме съвсем нормални десетични числа (цифри вместо букви)
   s = 163423 и имаме хеша на всеки негов префикс:
      h[0] = 1
      h[1] = 16
      h[2] = 163
      h[4] = 1634
      h[5] = 16342
      h[6] = 163423
   как ще вземем числото между позиции 2 и 5 (342) използвайки h? Еми то е равно на h[5]=16342 ама без първите 2 цифри. Как ще ги маанем? Еми ще извадим от него 16000, което е h[1]*10^3. Я виж ти - излезе. Хешът на низа между позиции [a,b] е равен на 
                           [code]хеша_до[b] - хеша_до[a-1] * основата ^ (b-a+1)[/code]

  нещата мисля, че са ясни. Остава само да не прецакаме някъде модулната аритметика и всичко ще е ок. Ето сега примерна реализация, step by step:

   ---променливите и precomputing-а
[code]
const int MAXN=1000002,MOD=1234567891,base=29;
char s[MAXN],p[MAXN];
int hs[MAXN],hp[MAXN];
int powbase[MAXN];

void getpows(int n)
{  powbase[0]=1; 
    for (int i=1;i<n;i++)
     powbase[i]=(long long)powbase[i-1]*base %MOD;     //това е обяснено по-надолу
}
[/code]

   --това нещо връща хеша до всяка позиция на s
[code]void hash(char *s,int n,int h[])
{
	h[0]=s[0]-'a'+1;
	for (int i=1;i<n;i++)
	 h[i]=( h[i-1]*base + s[i]-'a'+1 )%MOD;
}
[/code]

  --- а това връща хеша от позиция а до позиция b
[code]int hashmid(int h[],int a,int b)
{
	if (!a) return h[b];              //граничен случай - иначе долу ще извика h[-1] и ще даде грешка
	return ( h[b] - (long long)h[a]*powbase[b-a+1]%MOD + MOD )%MOD;  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
[/code]
         ВНИМАНИЕ! да погледнем втория ред. Защо е този лонг лонг? Защо прибавяме МОД и после отново вземаме %MOD? Първо, има умножение на елементи h[] и powbase[] - и двата са в интервала [0..MOD-1], но произведението им е ще е в интервала [0..(MOD-1)^2], което значи, че модулът трябва да е максимум корен квадратен от максимума на типа, иначе ще се сговни. Това значи, че или ще използваме модул <= 45000 (което е прекалено малко и шансът за колизии е доста по-голям), или ще извършим самото умножение в long long, което ни позволява модулът да е <= 2000000000. За целта пишем (long long) преди сметката и всичко се оправя, тъй като резултатът от това умножение е взет отново по модул и ще се върне в ограниченията на int. Сега имаме разлика на 2 числа в [0..MOD-1], което е число в интервала [-MOD+1,MOD-1]. Кофтиии. Как се оправяме с отрицателни числа? Ами, прибавяме им MOD и се оправят. Това става или като пишем if (x<0) x+=mod, или като направим (x+mod)%mod, което оправя отрицателните без да прецака положителните. 

  --остатъка от кода:
[code] int main()
{
		scanf("%s%s",s,p);
		getpows(strlen(s));
		hash(s,strlen(s),hs);
		int m=strlen(p);
		hash(p,m,hp);
		for (int i=0; s[i+m-1]; i++)           //надявам се знаете, че s[i+m-1] в случая е същото като i+m-1<strlen(s) щото символът след последния на s е "\0" демек 0 демек като стигне s[i+m-1] до него, цикълът ще спре
		 if (hashmid(hs,i,i+m-1)==hp[m-1]) printf("found at pos %d\n",i);
} [/code]

   иии това  хората му викат алгоритъм на Рабин-Карп.
   note: Понякога е по-добре да вземем 'a' да е равно на 1, вместо на 0. Вмомента горният код не различава "aaaaaa" от "aa" или "aaaaaab" от "aaab" и "b" и единствената причина да работи е, че винаги питаме за низ с фиксирана дължина. Да, но в повечето случаи, когато сравняваме 2 думи по хешовете им, няма да питаме отделно за дължините им и може да се издъни. [u]Така че вземайте на 'a' да съответства 1 !!![/u]

[b]5) още варианти [/b]

  а) за Рабин-Карп
   естествено, модулът може да е друг, основата също, стига 1) да са взаимно прости 2) сметките да се събират в съответните типове 3) модулът да е достатъчно голям, за да няма (почти) колизии 4) основата да не е кой знае колко по-голяма от азбуката

  б) по принцип
    ---ето един трик, който много улеснява модулните лайна. Знаете ли какво става, когато даден тип направи overflow? Имаме int a=2147483647; a++; printf("%d\n",a); Какво се получава? -2147483648. В действителност, при overflow променливата "прескача" от най-голямата в най-малката стойност на типа. Ами какво ако имаме unsigned int a=2^32-1; a++; ? Отговорът е 0. Излиза, че overflow-ът е своеобразна модулна аритметика, само че по модул 2^32 за unsigned int и 2^64 за unsigned long long. Можем да се възползваме от това, като по този начин освен че модулът може да е на квадрат пъти по-голям (вече ограничението заради умножението го няма - то само си прехвърля типа и все едно се взема по остатък) при което шансът за колизия става почти 0, и самото писане става по-лесно. Пример как това се използва конкретно в Rabin-Carp има в следващия пост.

  ---друг пример за хеширане - booi/2008/jori - вместо да сортираме буквите на всяка дума и да правим стандартно хеширане (както правя аз), може хешът да ни е 2^cnt['a'] * 3^cnt['b'] * 5^cnt['c'] * 7^cnt['d'] * 11^cnt['e'] .... абе произведение на просто число, повдигнато на степен броя пъти, които се среща дадена буква в думата. Кодът е много прост:
[code]int primes[]={2,3,5,7,11,13,17,23,....};
...
hash=1;
for (int i=0;s[i];i++) hash*=primes[s[i]-'a'];[/code]
и разнообразието е голямо, и няма нужда да сортираме, и колизиите са малко абе като цяло е яко (exod40 това е писал). Така че think outside the box! ;)

[b]6) hash table ???[/b]

  искаме структура, в която да вкарваме елементи и да питаме дали даден елемент е вътре с O(1). Елементите са огромни, а set<> е бавно. решението: hash table

въпросната таблица е масив с размер [MOD], който на всяка позиция има списък с такива елементи. на всеки обект (key) му правим hash value, като пъхаме на тази позиция в масива (таблицата) самия обект. Като питаме дали даден обект го има в таблицата, почваме да обхождаме списъка с обекти на позиция = хеш стойността му, като го търсим там. Пример:

[code]struct darvo{....};
const int MOD=123457;
vector<darvo> htable[MOD];

int hash(const darvo &a)
{ ..... return хеша на a в интервала 0..MOD-1;  }

void find(const darvo &a)
{
   int hval=hash(darvo);
   for (int i=0;i<htable[hval].size();i++)
    if (htable[hval][i]==a) return 1;
   return 0;
}

void push(const darvo &a)
{
   if (!find(a)) htable[hash(a)].push_back(a);
}
[/code]

тук самите списъци ни гарантират, че колизиите няма да преебат нещата. Единственото кофти на колизиите е, че ще правят по-дълги списъци (а на нас целта ни е списъците да са колкото се може по-равно разпределени по дължина, иначе ще стане линейно и се губи смисълът). Понякога обаче е неудобно такива списъци да се ползват и единственото, което остава, е да преценим дали евентуална колизия би била фатална. Примерно ако задачата иска да се каже всеки елемент колко пъти се среща, и една колизия само ще даде грешна бройка за някой от елементите и следователно грешен отговор на задачата. Ако обаче се пита кой е най-често срещаният елемент, в общия случай и да добавим 2-3 елемента където не трябва няма да е голяма болка за умиране. Това също е много важно - преценявайте доколко една колизия ще е фатална за задачата! И на базата на това вече мислете какъв подход ще ползвате, защото все пак колкото по-малко колизии искаме да има, толкова повече труд и време ще трябва да хвърлим. Иначе за hash_set и hash_map си има и вградени библиотеки, които е полезно да знаете да използвате:
http://6kola.eblahfree.com/Blah.pl?b-2/m-1231664986/


[i]tasks:
ceoi/2007/ministry
booi/2008/jori
USACO/2006/patterns
USACO training:
 cryptcow
 hidden
 msquare
 theme[/i]
срещания на подниз в низ - Rabin Carp - [b]това го искам от всеки на лично съобщение реализирано![/b]
дума 10^6 символа; яка позиция от думата е такава позиция, че като тръгнем от нея, стигнем до края на думата, върнем се в началото и стигнем до пак до нея, то получената дума е равна на нашта; кои са яките позиции? пример: dasdas отговор: 1 4



....бахти дисертацията изписах....





















[center][b]Rabin-Carp[/b] - намиране на подниз в низ:[/center]
хешираме стринга, който ще търсим, и за всеки кандидат от големия стринг просто сравняваме хеша му с този на търсения (вместо да го обхождаме символ по символ)


реализация от Емо (решението се възползва от overflow-а на unsigned long long, при което все едно всички аритметични операции се извършват по модул 2^64, само дето не се налага всеки път да пишем %MOD и е по-бързичко)

[code]#include<iostream>
#include<string.h>
using namespace std;
unsigned long long base=31,mod=1<<64;
unsigned long long n,m,hw[1024],hs[1024],powb[1024],k,i,t,p;
char s[1024],w[1024];
void hashs()
{ unsigned long long q;
  hs[0]=s[0]-'a'+1;
  for(q=1;q<=n-1;q++)
  { hs[q]=hs[q-1]*base+(s[q]-'a'+1);
  }
}
void hashw()
{ unsigned long long q;
  hw[0]=w[0]-'a'+1;
  for(q=1;q<=m-1;q++)
  { hw[q]=hw[q-1]*base+(w[q]-'a'+1);
  }
}
unsigned long long hash1(unsigned long long a,unsigned long long b)
{ if (a==0) return hs[b];
  unsigned long long res=hs[b]-hs[a-1]*powb[b-a+1];
  return res;
}
int main()
{ cin.getline(s,1000);
  cin.getline(w,1000);
  n=strlen(s);
  m=strlen(w);
  hashw();
  hashs();
  powb[0]=1;
  for(i=1;i<=n;i++) powb[i]=(powb[i-1]*base);
  k=n-m;
  for(i=0;i<=k;i++)
  { t=hash1(i,i+m-1); 
    if (t==hw[m-1]) { p=i;break;}
  }
  cout<<p<<endl;
return 0;
}[/code]


...все още чакам още решения ;)