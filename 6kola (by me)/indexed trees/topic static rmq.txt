[center][size=14][b]Static RMQ[/b][/size][/center]

имаме стойности в масив 0..N-1, искаме да можем да отговаряме на заявки за минимум/максимум стойност в даден интервал от масива (за удобство ще считаме, че ни интересува само стойността, а не позицията на въпросния елемент в масива, но иначе е същото)

след като предварително са ни дадени стойностите (за разлика от динамичното RMQ), можем да преизчислим някои неща и да си облекчим живота. В началото пълним таблица rmq[logN][N], така че rmq[k][n] пази най-малката стойност от елементите в интервала [ n , n+2^k ]. Забелязваме, че за да сметнем rmq[k][n] ни трябват само rmq[k-1][n] и rmq[k-1][n+(1<<(k-1))], което прави сложността на цялото попълване O(NlogN)

[code]#define MAXN (1<<19)
int rmq[20][MAXN];
int a[MAXN],N;

void initialize()
{
	for (int i=0;i<N;i++)
	 rmq[0][i]=a[i];
	for (int pow=0,step=1; step<N; pow++,step<<=1)
	 for (int i=0; i+step<N; i++)
	  rmq[pow][i] = min( rmq[pow][i] , rmq[pow][i+step] );
}
[/code]


за да разберем минимума в интервал [x,y] може просто да намерим два (евентуално препокриващи се) интервала с размер 2^i, единият започващ в x, а другият - завършващ в у, които да покрият всички елементи от търсения интервал [x,y]. Демек намираме най-голямата степен на две (2^k), която е по-малка от (или равна на) размера на интервала, и тогава резултатът на query-то е по-малкото от rmq[k][x] , rmq[k][y - (1<<k) +1]

[code]int query (int l, int r)
{
    int row, len;
    for(row=0,len=1; len<r-l+1; row++,len<<=1);
    return min( t[row][l], t[row][r-len+1] );
}[/code]

на това сложността му е logN. Обаче има по-хитър начин да намерим най-голямата степен на двойката, по-малка от или равна на дадено число. Да погледнем двоичния запис на числата - 6 в двоична бройна система е 110. Коя е най-голямата степен на двойката, по-малка от нея? 4 = 100. Ами на 10 = 1010? 8 = 1000. Ами на 110110 ? Очевидно 100000. Вижда се, че това винаги е единица с толкова нули след нея, колкото са цифрите в началното число, без една. Тук на помощ идва вградената __builtin_clz(x) (count leading zeroes), която връща колко нули има в началото на двоичния запис на х (демек преди първия set-нат бит). Самия брой на двоичните цифри на х намираме като извадим този брой от общия брой на цифрите във въпросния тип. За int този брой е 32, демек имаме 32-__builtin_clz(x). От това трябва да извадим 1 и да повдигнем 2 на тази степен. 

[code]
int query(int l,int r)
{
      int pow=31-__builtin_clz(r-l+1),step=1<<pow;
      return min( rmq[pow][l] , rmq[pow][r-step+1] );
}[/code]

това вече фърчи с O(1). Ето и статията в topcoder, където е показано RMQ е обяснено и приложението му в намирането на [b]Lowest Common Ancestor (LCA) [/b]на два върха в дърво: http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=lowestCommonAncestor

[i]задачки (не че можете да ги решите само с този материал, но все пак):
noi/2008/k5/lesna (LCA)
noi/2006/k1/maxsqu (2D)[/i]